<html>
	<head>
	   <script src="./bower_components/d3/d3.min.js"></script>
	   <script src="./bower_components/dimple/dist/dimple.v2.1.2.js"></script>
	   <script src="./bower_components/regression-js/build/regression.min.js"></script>
		<script src="./bower_components/waveform-data/dist/waveform-data.js"></script>
		
		<script src="./bower_components/jquery/dist/jquery.min.js"></script>
		<script src="./bower_components/ionrangeslider/js/ion.rangeSlider.js"></script>

		<script src="./scripts/waveform-layouts.js"></script>
		<script src="./scripts/stats.js"></script>

		<script type="text/javascript">
			// Again this is 0-based...
		var stream_names = ["", "Material", "Formal", "Interface", "Interaction"];
	 	var timeFormat = d3.time.format("%M:%S:%L");
		var timeMinsSecs = d3.time.format("%M:%S");
	 
		   function calculate_durations(data) {
				 var previous_time = null;
				 var format = d3.time.format("%M:%S:%L");
				 for (var i = 0; i < data.length; i++) {
					 // console.log(stream_times[data[i].streamid]);
					 if (previous_time != null) {
						 data[i].duration_all_streams = (format.parse(data[i].time) - format.parse(previous_time))/1000;
					 } else {
						 data[i].duration_all_streams = 0;
					 }
					 previous_time = data[i].time;
				 };
			};
		
			function calculate_durations_per_stream(data) {
				// stream_ids are actually 1-4 so initializing 0-4 but won't use 0.
				 var stream_times = [null, null, null, null, null];
				 var format = d3.time.format("%M:%S:%L");
				 for (var i = 0; i < data.length; i++) {
					 // console.log(stream_times[data[i].streamid]);
					 if (stream_times[data[i].streamid] != null) {
						 data[i].duration_per_stream = 
						 	(format.parse(data[i].time) - format.parse(stream_times[data[i].streamid]))/1000;
					 } else {
						 data[i].duration_per_stream = 0;
					 }
					 stream_times[data[i].streamid] = data[i].time;
				 };
			};
			
			function add_stream_name(data) {
				for (var i = 0; i < data.length; i++) {
					data[i].stream_name = stream_names[data[i].streamid];
				}
				// return data;
			}
						
		</script>
			
		<script type="text/javascript">
			// load stats module
		   rodstat = stats();
			
			// calc stats & display
			d3.csv("./Everything 1a.csv", function (data) {
			 rodstat.cooccurrence(d3.select("#stats1"), data);
		  	 rodstat.activitySummary(d3.select("#stats2"),data);
		  	 rodstat.durationPerStream(d3.select("#stats3"),data);
		   });
		</script>
		
		<link rel="stylesheet" href="bower_components/ionrangeslider/css/ion.rangeSlider.css" type="text/css" media="screen">
		<link rel="stylesheet" href="bower_components/ionrangeslider/css/ion.rangeSlider.skinHTML5.css" type="text/css" media="screen">

		<link rel="stylesheet" href="./style/rodalytics.css" type="text/css" media="screen">
		<!-- this is from oncletom's d3 waveform-live -->
		<link rel="stylesheet" href="./style/waveform-view.css" type="text/css" media="screen">
		
	</head>
	
	<body>
		<h1>Rodalytics v0.8 - Everything 1a</h1>
		
		<div class="sliderContainer">
			<input type="text" name="range_slider" value="" id="range_slider">
		</div>
		<script type="text/javascript">

		// min interval 12 seconds because less breaks our waveform display
		// console.log(timeFormat.parse("00:00:00"));
			$("#range_slider").ionRangeSlider({
				type: 'double',
				min: 0,
				max: 209,
				from: 0,
				to: 209,
				min_interval: 12,
				prettify_enabled: true,
				prettify: function (num) {
					return timeMinsSecs(new Date(num*1000));
				},
				onFinish: function (data) {
					leftBound = data.from;
					rightBound = data.to;
					applyBounds();
				}
			});
			
		</script>

		<div id="waveform">
			<div class="graph" id="waveform-graph" data-format="binary" data-url="Everything 1a.mp3" data-layout="area">
			  <!-- <div class="controls">
			    <button data-navigate="previous">Previous</button><button data-navigate="next">Next</button><button data-navigate="zoom">Zoom In</button><button data-navigate="dezoom">Zoom Out</button>
			  </div> -->
			</div>
			
			<script type="text/javascript">
			var size = { width: 1000, height: 150 };
			var formats = {
			  json: { "extension": "json", "mimeType": "application/json", "responseType": "json" },
			  binary: { "extension": "raw", "mimeType": "application/octet-stream", "responseType": "arraybuffer" }
			};
			
			var waveform_layout = null;
			
			var graphs = d3.selectAll(".graph[data-format]");
			graphs.append("svg")
			    .attr("width", size.width)
			    .attr("height", size.height)


			graphs.each(function(){
				var format = formats[this.getAttribute("data-format")];
				var programme = this.getAttribute("data-programme");

				var config = {
				  event_identifier: ["load", programme, format.extension].join("."),
				  format: format,
				  size: size,
				  programme: programme,
				  layout: this.getAttribute("data-layout"),
				  resample: true,
				  data_url: this.getAttribute("data-url") || "./data-"+programme+"."+format.extension
				};

				var layout = layouts(d3.select(this).select("svg"), config);
				waveform_layout = layout;

				var xhr = d3.xhr(config.data_url, format.mimeType);
				xhr.responseType(format.responseType);

				xhr.on(config.event_identifier, layout.init.bind(layout));
				xhr.get();

				this.addEventListener("mousemove", function(event){
					var timeInSeconds = waveform_layout.time(parseInt(event.x)-70);
					var datecode = new Date((timeInSeconds+parseInt(leftBound))*1000);
					d3.select("#waveform_position")[0][0].value = timeMinsSecs(datecode);
				});
				 
			});

			</script>

		</div>
		<div class="chartControls">
			<span class="chartTitle">Waveform</span>
			<div><audio src="Everything 1a.mp3" preload="auto" controls></audio></div>
			<div><output id="waveform_position">00:00</output></div>
		</div>

		<div class="clear">
		</div>


		<div id="chartContainer" class="chartContainer">
		</div>
		<div id="chartControls" class="chartControls">
			<span class="chartTitle">Chart 1</span>
			<input type="button" name="btn_all_cat" value="All categories" id="btn_all_cat">
			<input type="button" name="btn_same_cat" value="Same category" id="btn_same_cat">
		</div>
	  <script type="text/javascript">
		 var svg = dimple.newSvg("#chartContainer", 1100, 500);
		 var myChart = null;
		 var myData = null;
		 var mySeries = null;
		 var leftBound = 0;
		 var rightBound = 200;
		 
		 function bubbleClickAudio(series, audioPlayer) {
			 // this has to be after dimple.chart.draw() in order to work!
			 // no need to remove the old listeners as d3 automatically replaces them
			 series.shapes.on("click", function (e) {
				audioPlayer.currentTime = (e.x.getMinutes()*60)+e.x.getSeconds();
			 });
		 	
		 }

		 d3.csv("./Everything 1a.csv", function (data) {
		  	 // data = dimple.filterData(data, "id", "3");
		 	 // console.log(data);

 		    myData = data;
			 
			 // possibly change csv file format using this
			 calculate_durations(myData);
			 calculate_durations_per_stream(myData);
			 myData.map(function (d) {
			 	d.duration = d.duration_all_streams;
			 })
			 add_stream_name(myData);
			 // console.log(myData);
			 myChart = new dimple.chart(svg, myData);
 		    myChart.setBounds(60, 0, 1000, 430);
 		    var x = myChart.addTimeAxis("x", "time", "%M:%S:%L", "%M:%S");
			 x.timePeriod = d3.time.seconds;
			 x.timeInterval = 10;
			 // x.overrideMax = timeFormat.parse(maxTime);
			 
 		    var y = myChart.addCategoryAxis("y", "stream_name");
			 y.addOrderRule(stream_names, true);
			 
			 myChart.addMeasureAxis("z", "duration");
 		    // myChart.addLegend(700, 10, 360, 50, "left");
			 mySeries = myChart.addSeries("stream_name");

			 // replace the tooltip with our custom handler
			 // main job is to correctly get simultaneous events & 
			 // to enrich display with comments without causing recolouring
			 mySeries.getTooltipText = function (seriesObject) {
				 var events = myData.filter(function (d) {
					var searchTime = timeFormat(seriesObject.cx);
					return (( d.time == searchTime.substring(0, searchTime.length - 1)) && 
								(d.stream_name == seriesObject.cy));
				 })

				 var tooltip = [ "Time: "+timeMinsSecs(seriesObject.cx) ];

				 events.forEach(function (myevent) {
					 tooltip.push("Event type: "+myevent.stream_name);
 					 tooltip.push("Comment: "+myevent.comment);
				 });
				 return tooltip;
			 }

			 // this changes the colouring!
			 // myChart.addSeries("comment", null);
			  
			 myChart.assignColor("Material", "#fea18d");
			 myChart.assignColor("Formal", "#93d1ff");
			 myChart.assignColor("Interface", "#b7e695");
			 myChart.assignColor("Interaction", "#fefca2");
			 
 		    myChart.draw();
			 bubbleClickAudio(mySeries,d3.select('audio')[0][0]);

		 });
		 
		 
		 
		d3.select("#btn_all_cat").on("click", function() {
			myData.map(function (d) {
				d.duration = d.duration_all_streams;
			})
			myChart.draw(1000);
			// don't need to redo the click handlers because bounds don't change 
		});

		d3.select("#btn_same_cat").on("click", function() {
			myData.map(function (d) {
				d.duration = d.duration_per_stream;
			})
		 	myChart.draw(1000);
			// don't need to redo the click handlers because bounds don't change 
		});

		// zooming controls

		function applyBounds() {
			// apply to chart 1
			myChart.data = myData.filter(function (d, index) {
				return ((((timeFormat.parse(d.time)-timeFormat.parse("00:00:00"))/1000) >= leftBound ) &&
							((timeFormat.parse(d.time)-timeFormat.parse("00:00:00"))/1000) <= rightBound);
			});

			var x = myChart.axes[0];
			// fix the scales on the graph
			var dateMin = new Date(leftBound*1000);
			var dateMax = new Date(rightBound*1000);
			x.overrideMin = dateMin.setFullYear(1900);
			x.overrideMax = dateMax.setFullYear(1900);

		 	myChart.draw(1000);
			// redo click handlers
			bubbleClickAudio(mySeries,d3.select('audio')[0][0]);

			// apply to waveform display
			waveform_layout.setBounds(leftBound,rightBound);
			
		}

	  </script>
		
		<div class="clear"></div>
				
		<div id="chartContainer2" class="chartContainer">
		</div>
		<div id="chartControls2" class="chartControls">
			<span class="chartTitle">Chart 2</span>
			<input type="button" name="btn2_cat_all" value="All streams" id="btn2_cat_all" class="All streamSelection">
			<input type="button" name="btn2_cat_1" value="Material" id="btn2_cat_1" class="Material streamSelection">
			<input type="button" name="btn2_cat_2" value="Formal" id="btn2_cat_2" class="Formal streamSelection">
			<input type="button" name="btn2_cat_3" value="Interface" id="btn2_cat_3" class="Interface streamSelection">
			<input type="button" name="btn2_cat_4" value="Interaction" id="btn2_cat_4" class="Interaction streamSelection"> 
		</div>
		
		  <script type="text/javascript">
			 var svg2 = dimple.newSvg("#chartContainer2", 1100, 600);
			 var myChart2 = null;
			 var myData2 = null;
			 var minTime, maxTime, maxDuration = null;
			 var x,y = null;
			 
			 d3.csv("./Everything 1a.csv", function (data) {
			  	 // data = dimple.filterData(data, "id", "3");
			 	 // console.log(data);

	 		    myData2 = data;
				 
				 // possibly change csv file format using this
				 calculate_durations(myData2);
				 calculate_durations_per_stream(myData2);
 				 myData2.map(function (d) {
 				 	d.duration = d.duration_all_streams;
 				 })
				 add_stream_name(myData2);
				 // console.log(myData2);
				 
				 minTime = d3.min(myData2, function (d) {
					 return d.time;
					 
				 });
					 
				 maxTime = d3.max(myData2, function (d) {
					 return d.time;
				 })

				 var maxDuration = d3.max(myData2, function (d) {
					 return d.duration_per_stream;
				 })
				 
				 maxDuration = d3.max(myData2, function (d) {
				       return d.duration_per_stream;
				 })

				 myChart2 = new dimple.chart(svg2, myData2);
	 		    myChart2.setBounds(60, 30, 1000, 530);
	 		    x = myChart2.addTimeAxis("x", "time", "%M:%S:%L", "%M:%S");
				 // x.addOrderRule("Date");
				 x.timePeriod = d3.time.seconds;
				 x.timeInterval = 10;
				 
				 x.overrideMin = timeFormat.parse(minTime);
				 x.overrideMax = timeFormat.parse(maxTime);
				 
				 y = myChart2.addMeasureAxis("y", "duration_per_stream");
				 y.overrideMax = maxDuration;
				 
				 // myChart2.addSeries("comment");
				 myChart2.addSeries("stream_name", dimple.plot.bubble, [x,y]);
				 
				 calculate_regression(myChart2);
				 
				 var y2 = myChart2.addMeasureAxis("y","stream_regression");
				 // set second axis to match first one
				 y2.overrideMax = maxDuration;
				 
				 var lines = myChart2.addSeries(null, dimple.plot.line, [x,y2]);
	 		    
				 myChart2.assignColor("Material", "#fea18d");
				 myChart2.assignColor("Formal", "#93d1ff");
				 myChart2.assignColor("Interface", "#b7e695");
				 myChart2.assignColor("Interaction", "#fefca2");
				 
				 // myChart2.addLegend(140, 10, 360, 20, "left");
	 		    myChart2.draw();

	 		 });

 			d3.select("#btn2_cat_all").on("click", function() {
 				myChart2.data = myData2;
				calculate_regression(myChart2);
 				myChart2.draw(1000);
 			});

			function create_btn2(index) {
				return function() {
					myChart2.data = dimple.filterData(myData2, "streamid", index.toString());
					calculate_regression(myChart2);
					myChart2.draw(1000);

				}
			}

			function calculate_regression(chart) {
				myData2.map(function (d) {
					d.time_offset = (timeFormat.parse(d.time)-timeFormat.parse(minTime))/1000;
				});
				var regressionData = chart.data.map(function (d) {
					return [d.time_offset,d.duration_per_stream];
				});
				// console.log(regressionData);
				var regression = window.regression('linear', regressionData );
				// console.log(regression);
				
				// chart.data can arrive unsorted by time_offset in some casse
				// therefore we have to check all time_offsets as our current graphing method
				// will error if we have two entries at the same time_offset
				// there's almost certainly a faster way to do this! 
				var previous_time_offsets = [];
				
				for (var j = 0; j < chart.data.length; j++) {
					if (previous_time_offsets.indexOf(chart.data[j].time_offset) == -1) { 
						chart.data[j].stream_regression = regression.points[j][1];
					} else {
						delete chart.data[j].stream_regression;
					} 
					previous_time_offsets.push(chart.data[j].time_offset);
				}
			}
		
			// move this code out into function because of scoping issues in closures!
			for (var i = 1; i < 5; i++) {
				d3.select("#btn2_cat_"+i).on("click", create_btn2(i));				
			}

		  </script>
			
		<div class="clear"></div>
			
			
		<div class="stats">
			<h2>Co-occurrence</h2>
			<div id="stats1">
			</div>
		</div>		
		
		<div class="stats">
			<h2>Activity Summary</h2>
			<div id="stats2">
			</div>		
		</div>
					
		<div class="stats">
			<h2>Duration stats per stream</h2>
			<div id="stats3">
			</div>
		</div>

	</body>
	
</html>