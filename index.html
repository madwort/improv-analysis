<!doctype html>
<html>
	<head>
		<meta charset="UTF-8">
	   <script src="./bower_components/d3/d3.min.js"></script>
	   <script src="./bower_components/dimple/dist/dimple.v2.1.2.js"></script>
	   <script src="./bower_components/regression-js/build/regression.min.js"></script>
		<script src="./bower_components/waveform-data/dist/waveform-data.js"></script>
		
		<script src="./bower_components/jquery/dist/jquery.min.js"></script>
		<script src="./bower_components/ionrangeslider/js/ion.rangeSlider.js"></script>

		<script src="./scripts/rodalytics.js"></script>
		<script type="text/javascript">
			// load our helper functions
			// need to load this before loading stats.js
			var ra = rodalytics();

			var audioUrl = "./Everything 1a.mp3";
			var dataUrl = "./Everything 1a.csv";
			var analysisName = "Everything. Everything at once. Once. (1a)";
			var videoUrl = "https://vimeo.com/77930437";
		</script>
		
		<script src="./scripts/waveform-layouts.js"></script>
		<script src="./scripts/stats.js"></script>
		
		<script type="text/javascript">
			// load stats module
			rodstat = stats();
		</script>
		
		<link rel="stylesheet" href="bower_components/normalize.css/normalize.css" type="text/css" media="screen">
		<link rel="stylesheet" href="bower_components/ionrangeslider/css/ion.rangeSlider.css" type="text/css" media="screen">
		<link rel="stylesheet" href="bower_components/ionrangeslider/css/ion.rangeSlider.skinFlat.css" type="text/css" media="screen">

		<link rel="stylesheet" href="./style/rodalytics.css" type="text/css" media="screen">
		<!-- this is from oncletom's d3 waveform-live -->
		<link rel="stylesheet" href="./style/waveform-view.css" type="text/css" media="screen">
		
	</head>
	
	<body>
		<div id="topbar">
			<div id="wrapper">
				<span id="title">Rodalytics v0.0.9</span>
				<script type="text/javascript">
				var titleObject = $("#title");
				titleObject.html(titleObject.text()+" - \<a href=\""+videoUrl+"\" target=\"_blank\"\>"+analysisName+"\</a\>");
				</script>
				
				<div class="sliderContainer">
					<input type="text" name="range_slider" value="" id="range_slider">
				</div>
				<script type="text/javascript">
		
					// min interval 12 seconds because less breaks our waveform display
					// console.log(ra.timeFormat.parse("00:00:00"));
					$("#range_slider").ionRangeSlider({
						type: 'double',
						min: 0,
						max: 209,
						from: 0,
						to: 209,
						min_interval: 12,
						prettify_enabled: true,
						prettify: function (num) {
							return ra.timeMinsSecs(new Date(num*1000));
						},
						onFinish: function (data) {
							leftBound = data.from;
							rightBound = data.to;
							applyBounds();
						}
					});
					
				</script>
				<span id="audioPlayer"><audio src="" controls></audio></span>
				<script type="text/javascript">
					// the sooner we do this, the sooner we get the remote file data loaded
					// otherwise could just call applyBounds() now
					d3.select('audio')[0][0].src = audioUrl;
				</script>
			</div>
		</div>
		<div id="content">		
				<div id="waveform">
					<div class="graph" id="waveform-graph" data-format="binary" data-url="" data-layout="area"></div>
					<output id="waveform_position">00:00</output>
		
					<script type="text/javascript">
					var size = { width: 1000, height: 149 };
					var formats = {
					  json: { "extension": "json", "mimeType": "application/json", "responseType": "json" },
					  binary: { "extension": "raw", "mimeType": "application/octet-stream", "responseType": "arraybuffer" }
					};
					
					var waveform_layout = null;
					
					var graphs = d3.selectAll(".graph[data-format]");
					graphs.append("svg")
					    .attr("width", size.width)
					    .attr("height", size.height)
		
		
					graphs.each(function(){
						this.setAttribute("data-url",audioUrl);
						var format = formats[this.getAttribute("data-format")];
						var programme = this.getAttribute("data-programme");
		
						var config = {
						  event_identifier: ["load", programme, format.extension].join("."),
						  format: format,
						  size: size,
						  programme: programme,
						  layout: this.getAttribute("data-layout"),
						  resample: true,
						  data_url: this.getAttribute("data-url") || "./data-"+programme+"."+format.extension
						};
		
						var layout = layouts(d3.select(this).select("svg"), config);
						waveform_layout = layout;
		
						var xhr = d3.xhr(config.data_url, format.mimeType);
						xhr.responseType(format.responseType);
		
						xhr.on(config.event_identifier, layout.init.bind(layout));
						xhr.get();

						d3.select(".graph svg").on("mousemove", function(){
							var timeInSeconds = waveform_layout.time(d3.mouse(this)[0])+parseInt(leftBound);
							var datecode = new Date(timeInSeconds*1000);
							d3.select("#waveform_position")[0][0].value = ra.timeMinsSecs(datecode);
						});
		
						d3.select(".graph svg").on("click", function(){
							var timeInSeconds = waveform_layout.time(d3.mouse(this)[0])+parseInt(leftBound);
							d3.select('audio')[0][0].currentTime = timeInSeconds;
						});
						
		
					});
		
					</script>
		
				</div>
		
				<div class="clear"></div>
		
				<!-- chart 1 -->
		
				<div id="chartContainer" class="chartContainer">
				</div>
				<div id="chartControls" class="chartControls">
					<input type="button" name="btn_no_cat" value="No duration" id="btn_no_cat" class="chart1btn enabled">
					<input type="button" name="btn_all_cat" value="Duration all cats." id="btn_all_cat" class="chart1btn">
					<input type="button" name="btn_same_cat" value="Duration same cat." id="btn_same_cat" class="chart1btn">
				</div>
			  <script type="text/javascript">
				 var svg = dimple.newSvg("#chartContainer", 1100, 500);
				 var myChart = null;
				 var myData = null;
				 var mySeries = null;
				 var leftBound = 0;
				 var rightBound = 209;
				 var z = null;
				 
				 function bubbleClickAudio(series, audioPlayer) {
					 // this has to be after dimple.chart.draw() in order to work!
					 // no need to remove the old listeners as d3 automatically replaces them
					 series.shapes.on("click", function (e) {
						audioPlayer.currentTime = (e.x.getMinutes()*60)+e.x.getSeconds();
					 });
				 }

				 function drawPlayhead(index) {
					 d3.selectAll(".playhead").remove();
					 // but don't draw if it's offscreen - this mostly affects charts with SVG offsets
					 if (index>=0 || index <=1000) {
						 // draw on waveform
					 	d3.select(".graph svg").append("rect")
							.attr("x",index).attr("y",0).attr("width",2).attr("height",150).classed("playhead", true); 
					 	// draw on charts, offset x because SVG is wider to contain chart's axis
						d3.select("#chartContainer svg").append("rect")
							.attr("x",index+61).attr("y",0).attr("width",2).attr("height",430).classed("playhead", true);
						d3.select("#chartContainer2 svg").append("rect")
							.attr("x",index+61).attr("y",30).attr("width",2).attr("height",530).classed("playhead", true);
					 }
				 }

				 d3.csv(dataUrl, function (data) {
		 		    myData = data;
					 
					 // possibly change csv file format using this
					 ra.calculateDurations(myData);
					 ra.calculateDurationsPerStream(myData);
					 myData.map(function (d) {
					 	d.duration = 1;
					 })
					 ra.add_stream_name(myData);
		
					 myChart = new dimple.chart(svg, myData);
		 		    myChart.setBounds(60, 0, 1000, 430);
		 		    var x = myChart.addTimeAxis("x", "time", "%M:%S:%L", "%M:%S");
					 x.timePeriod = d3.time.seconds;
					 x.timeInterval = 10;
					 x.overrideMin = ra.timeFormat.parse("00:00:00")
					 
		 		    var y = myChart.addCategoryAxis("y", "stream_name");
					 y.addOrderRule(ra.stream_names, true);

 					 z = myChart.addMeasureAxis("z", "duration");
					 // default is equally sized bubbles
					 z.overrideMin = 0;
					 z.overrideMax = 10;
					 
					 
					 mySeries = myChart.addSeries("stream_name");
		
					 // replace the tooltip with our custom handler
					 // main job is to correctly get simultaneous events & 
					 // to enrich display with comments without causing recolouring
					 mySeries.getTooltipText = function (series) {
						 var events = data.filter(function (d) {
							 var searchTime = ra.timeFormat(series.cx);
							 return (( d.time == searchTime.substring(0, searchTime.length - 1)) && 
								(d.stream_name == series.cy));
							})
							var tooltip = [ "Time: "+ra.timeMinsSecs(series.cx) ];

							events.forEach(function (myevent) {
								tooltip.push("Event type: "+myevent.stream_name);
								tooltip.push("Comment: "+myevent.comment);
							});
							return tooltip;
						};

					 myChart.assignColor("Material", "#fea18d");
					 myChart.assignColor("Formal", "#93d1ff");
					 myChart.assignColor("Interface", "#b7e695");
					 myChart.assignColor("Interaction", "#fefca2");
					 
		 		    myChart.draw();
					 bubbleClickAudio(mySeries,d3.select('audio')[0][0]);
 					 applyBoundsChart1();

					 d3.select('audio')[0][0].addEventListener("timeupdate", function () {
						 drawPlayhead(waveform_layout.indexOfTime(this.currentTime));
					 })
					 
					 createStats(data);
					 
				 });

				 function disableAllChart1Btns() {
					 d3.selectAll('.chart1btn').classed("enabled", false);
				 }
				 
 				d3.select("#btn_no_cat").on("click", function() {
					z.overrideMin = 0;
					z.overrideMax = 10;
					myData.map(function (d) {
						d.duration = 1;
					});
					disableAllChart1Btns();
					d3.select("#btn_no_cat").classed("enabled",true);
 					myChart.draw(1000);
 					// don't need to redo the click handlers because bounds don't change 
 				});
				
				d3.select("#btn_all_cat").on("click", function() {
					z.overrideMin = null;
					z.overrideMax = null;
					myData.map(function (d) {
						d.duration = d.duration_all_streams;
					});
					disableAllChart1Btns();
					d3.select("#btn_all_cat").classed("enabled",true);
					myChart.draw(1000);
					// don't need to redo the click handlers because bounds don't change 
				});
		
				d3.select("#btn_same_cat").on("click", function() {
					z.overrideMin = null;
					z.overrideMax = null;
					myData.map(function (d) {
						d.duration = d.duration_per_stream;
					});
					disableAllChart1Btns();
					d3.select("#btn_same_cat").classed("enabled",true);
				 	myChart.draw(1000);
					// don't need to redo the click handlers because bounds don't change 
				});

				function createStats(data) {
					rodstat.activitySummary(d3.select("#activitySummary"),data);
					rodstat.cooccurrence(d3.select("#cooccurrence"), data);
				  	rodstat.durationPerStream(d3.select("#durationStats"),data);
					rodstat.activityLog(d3.select("#activityLog"),data);
				}

				function applyBoundsChart1() {
					// apply to chart 1
					myChart.data = myData.filter(function (d, index) {
						return ((((ra.timeFormat.parse(d.time)-ra.timeFormat.parse("00:00:00"))/1000) >= leftBound ) &&
									((ra.timeFormat.parse(d.time)-ra.timeFormat.parse("00:00:00"))/1000) <= rightBound);
					});
		
					var x = myChart.axes[0];
					// fix the scales on the graph
					x.overrideMin = ra.timeFromSeconds(leftBound);
					x.overrideMax = ra.timeFromSeconds(rightBound);
		
				 	myChart.draw(1000);
					// redo click handlers
					bubbleClickAudio(mySeries,d3.select('audio')[0][0]);
				}

				// Update everything when we change the zoom of waveform & chart 1
				function applyBounds() {
					applyBoundsChart1();
					applyBoundsChart2();
		
					// apply to waveform display
					waveform_layout.setBounds(parseInt(leftBound),parseInt(rightBound));
		
					// apply to audio playback 
					var audioPlayer = d3.select('audio')[0][0];
					audioPlayer.pause();
					audioPlayer.src = audioUrl+"#t="+leftBound+","+rightBound;
					// this also resets the playback time to zero, so do that too...
					drawPlayhead(0);
					
					
					// apply to stats
					// This is a bit inefficient - removing the whole table & re-rendering
					// but it is simple & expendient!
					d3.select('#activitySummary table').remove();
					d3.select('#cooccurrence table').remove();
					d3.select('#durationStats table').remove();
					d3.select('#activityLog table').remove();
					createStats(myChart.data);
					
				}
		
			  </script>
				
				<div class="clear"></div>
		
				<div id="chartControls2" class="">
					<span class="chartTitle" id="trendChart">Trend chart</span>
					<input type="button" name="btn2_cat_all" value="All streams" id="btn2_cat_all" class="All streamSelection">
					<input type="button" name="btn2_cat_1" value="Material" id="btn2_cat_1" class="Material streamSelection">
					<input type="button" name="btn2_cat_2" value="Formal" id="btn2_cat_2" class="Formal streamSelection">
					<input type="button" name="btn2_cat_3" value="Interface" id="btn2_cat_3" class="Interface streamSelection">
					<input type="button" name="btn2_cat_4" value="Interaction" id="btn2_cat_4" class="Interaction streamSelection"> 
				</div>
				
				<div class="clear"></div>
				
				<div id="chartContainer2" class="chartContainer">
				</div>
				
				  <script type="text/javascript">
					 var svg2 = dimple.newSvg("#chartContainer2", 1100, 600);
					 var myChart2 = null;
					 var myData2 = null;
					 var mySeries2 = null;
					 // weirdly, this global is ref'd on rodalytics.js:50
					 // refactor...
					 var minTime = null;
					 var x,y = null;
					 var currentStream = null;
					 var lines = null;
					 
					 d3.csv(dataUrl, function (data) {
					  	 // data = dimple.filterData(data, "id", "3");
					 	 // console.log(data);
		
			 		    myData2 = data;
						 
						 // possibly change csv file format using this
						 ra.calculateDurations(myData2);
						 ra.calculateDurationsPerStream(myData2);
		 				 myData2.map(function (d) {
		 				 	d.duration = d.duration_all_streams;
		 				 })
						 ra.add_stream_name(myData2);
						 // console.log(myData2);
						 
						 minTime = d3.min(myData2, function (d) {
							 return d.time;
						 });
							 
						 var maxTime = d3.max(myData2, function (d) {
							 return d.time;
						 })
		
						 var maxDuration = d3.max(myData2, function (d) {
							 return d.duration_per_stream;
						 })

						 myChart2 = new dimple.chart(svg2, myData2);
			 		    myChart2.setBounds(60, 30, 1000, 530);
			 		    x = myChart2.addTimeAxis("x", "time", "%M:%S:%L", "%M:%S");
						 // x.addOrderRule("Date");
						 x.timePeriod = d3.time.seconds;
						 x.timeInterval = 10;
						 
						 x.overrideMin = ra.timeFormat.parse(minTime);
						 x.overrideMax = ra.timeFormat.parse(maxTime);
						 
						 y = myChart2.addMeasureAxis("y", "duration_per_stream");
						 y.overrideMax = maxDuration;
						 
						 // myChart2.addSeries("comment");
						 mySeries2 = myChart2.addSeries("stream_name", dimple.plot.bubble, [x,y]);
						 mySeries2.getTooltipText = function (series) {
							 var events = data.filter(function (d) {
								 var searchTime = ra.timeFormat(series.cx);
								 return (( d.time == searchTime.substring(0, searchTime.length - 1)) && 
									(d.stream_name == series.aggField[0]));
								})
								var tooltip = [ "Time: "+ra.timeMinsSecs(series.cx) ];

								events.forEach(function (myevent) {
									tooltip.push("Event type: "+myevent.stream_name);
									tooltip.push("Comment: "+myevent.comment);
								});
								return tooltip;
							};
						 
						 ra.calculate_regression(myChart2, myData2);
						 
						 var y2 = myChart2.addMeasureAxis("y","stream_regression");
						 // set second axis to match first one
						 y2.overrideMax = maxDuration;
						 
						 lines = myChart2.addSeries(null, dimple.plot.line, [x,y2]);
						 
						 myChart2.assignColor("Material", "#fea18d");
						 myChart2.assignColor("Formal", "#93d1ff");
						 myChart2.assignColor("Interface", "#b7e695");
						 myChart2.assignColor("Interaction", "#fefca2");
						 
						 // myChart2.addLegend(140, 10, 360, 20, "left");
			 		    myChart2.draw();
						 // this is a bit of a hack, but I couldn't get this to work through dimple
						 lines.shapes[0][0].setAttribute("stroke","#00282A");
						 bubbleClickAudio(mySeries2,d3.select('audio')[0][0]);

	 					 applyBoundsChart2();
						 
			 		 });
		
		 			d3.select("#btn2_cat_all").on("click", function() {
						currentStream = null;
					 	lines.shapes[0][0].setAttribute("stroke","#00282A");
						applyBoundsChart2();
		 			});

					function applyBoundsChart2() {
						// apply to chart 2
						
						if (currentStream !== null) {
							myChart2.data = dimple.filterData(myData2, "streamid", currentStream.toString());
							ra.calculate_regression(myChart2, myData2);
						} else { 
							myChart2.data = myData2;
						}
						
						myChart2.data = myChart2.data.filter(function (d, index) {
							return ((((ra.timeFormat.parse(d.time)-ra.timeFormat.parse("00:00:00"))/1000) >= leftBound ) &&
										((ra.timeFormat.parse(d.time)-ra.timeFormat.parse("00:00:00"))/1000) <= rightBound);
						});

						ra.calculate_regression(myChart2, myData2);

						var x = myChart2.axes[0];
						// fix the scales on the graph
						x.overrideMin = ra.timeFromSeconds(leftBound);
						x.overrideMax = ra.timeFromSeconds(rightBound);
						
					 	myChart2.draw(1000);
						// redo click handlers
						bubbleClickAudio(mySeries2,d3.select('audio')[0][0]);
					}
					

					function create_btn2(index) {
						return function() {
							currentStream = index;
						 	lines.shapes[0][0].setAttribute("stroke",ra.stream_colours[index]);
							applyBoundsChart2();
						}
					}
				
					// move this code out into function because of scoping issues in closures!
					for (var i = 1; i < 5; i++) {
						d3.select("#btn2_cat_"+i).on("click", create_btn2(i));				
					}
		
				  </script>

				<div class="clear"></div>

				<div class="stats">
					<h2>Activity Summary</h2>
					<div id="activitySummary"></div>
				</div>		
				
				<div class="stats">
					<h2>Co-occurrence</h2>
					<div id="cooccurrence"></div>		
				</div>
							
				<div class="stats">
					<h2>Duration stats per stream</h2>
					<div id="durationStats"></div>
				</div>
				
				<div class="clear"></div>
				
				<div class="stats">
					<h2>Activity log</h2>
					<div id="activityLog"></div>
				</div>
		</div>
	</body>
	
</html>